---
published: false
description: Ein writeup zu dem TryHackMe Raum Overpass.
tags:
  - security
  - linux
  - ctf
---
Ein writeup zum TryHackMe-Raum [Overpass](https://tryhackme.com/room/overpass)

**Info Notice:** Overpass - What happens when some broke CompSci students make a password manager?
{: .notice--info}

## Disclaimer

Vorweg der übliche Disclaimer: ihr könnt die Tools, welche hier vorgestellt werden für euer eigenes Netzwerk verwenden oder im Rahmen eines Penetration Tests einsetzen, wenn ihr dafür beauftragt wurdet. Jedoch dürft ihr diese Tools niemals gegen fremde Systeme ohne explizite Erlaubnis einsetzen.

## Ziel

Zwei Flags müssen gefunden werde - eine User- und eine Rootflag.

* Hack the machine and get the flag in user.txt 
* Escalate your privileges and get the flag in root.txt

## Aufklärung

Als erstes machen wir einen Portscan mit nmap.

`nmap -A $ipaddress -o nmap.txt`

{:refdef: style="text-align: center;"}
![Ergebnis des nmap Scans]({{ site.baseurl }}/images/overpass_nmap.png)
{: refdef}

Wir finden einen offenen SSH-Server (Port 22) und einen Webserver (Port 80).

## Untersuchung des Webservers

Auf der Website wird Overpass vorgestellt - ein sicherer Passwortmanager.

{:refdef: style="text-align: center;"}
![Die Webseite von Overpass]({{ site.baseurl }}/images/overpass_website.png)
{: refdef}

Mit ffuf scannen wir den Webserver nach Ordnern und finden unter /admin ein Loginformular.

{:refdef: style="text-align: center;"}
![Ergebnis des ffuf directory scans]({{ site.baseurl }}/images/overpass_ffuf.png)
{: refdef}

{:refdef: style="text-align: center;"}
![Loginforumlar auf der Adminseite]({{ site.baseurl }}/images/overpass_admin.png)
{: refdef}

Über die Developer Tools des Browsers sehen können wir Java Script untersuchen, welches beim Login ausgeführt wird. Die Datei heißt login.js.

Bei genauerem Hinsehen fällt auf, dass die Abfrage von Username und Passwowrd übersprungen wird, wenn ein Cookie mit dem Key SessionToken und beliebigem Value gesetzt ist.

{:refdef: style="text-align: center;"}
![JavaScript-Code Ausschnitt. Wenn SessionToken gesetzt ist, wird Passwortabfrage übersprungen.]({{ site.baseurl }}/images/overpass_js.png)
{: refdef}

{% highlight js %}
async function login() {
    const usernameBox = document.querySelector("#username");
    const passwordBox = document.querySelector("#password");
    const loginStatus = document.querySelector("#loginStatus");
    loginStatus.textContent = ""
    const creds = { username: usernameBox.value, password: passwordBox.value }
    const response = await postData("/api/login", creds)
    const statusOrCookie = await response.text()
    if (statusOrCookie === "Incorrect credentials") {
        loginStatus.textContent = "Incorrect Credentials"
        passwordBox.value=""
    } else {
        Cookies.set("SessionToken",statusOrCookie)
        window.location = "/admin"
    }
}
{% endhighlight %}

Wir verfizieren dies, in dem wir in den Developer Tools unter Storage einen Cookie mit dem Namen SessionToken und beliebigem Value setzen. Anschließend laden wir die Seite einmal neu. Wir erhalten einen SSH-Key von James.

{:refdef: style="text-align: center;"}
![JavaScript-Code Ausschnitt. Wenn SessionToken gesetzt ist, wird Passwortabfrage übersprungen.]({{ site.baseurl }}/images/overpass_sshkey.png)
{: refdef}

## SSH-Verbindung aufbauen

Wir speichern den Key in einer Textdatei. Da dieser den Status Encrypted hat, müssen wir das Passwort cracken. Ohne das Passwort können wir uns mit dem Key nicht am Server authentifizieren. Dazu extrahieren wir den Hash mit ssh2john. 

```
ssh2john id_rsa > id_rsa.hash
```

Anschließend könnten wir den Hash mit John the Ripper cracken.

```
john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash
```
Wenn schon den Hash gecrackt hat, lassen wir uns das Passwort für den SSH-Key anzeigen.

``` 
john id_rsa.hash --show
``` 
Mit dem Passwort und dem SSH-Key können wir uns nun als User james per SSH am Server authentifizieren. Dort finden wir auch die Userflag.

{:refdef: style="text-align: center;"}
![Authentifizierung am Server via SSH und Anzeigen der Userflag.]({{ site.baseurl }}/images/overpass_userflag.png)
{: refdef}



## Privilege Escalation

Um an die zweite Flag zu kommen, müssen wir unsere Privilegien erhöhen, da diese nur für root zugänglich ist. Dazu nutzen wir die SUID-Berechtigungen. SUID steht für "set owner userID upon execution". Das bedeutet, dass ein Programm mit den Berechtigungen des Besitzers der Datei ausgeführt wird und nicht mit den Berechtigungen des Users, der die Datei ausführt. Wir suchen also eine Datei, welche mit root Berechtigungen ausgeführt wird. Mit `find / -perm /4000 2>/dev/null` finden wir heraus, dass /bin/systemctl die SUID Berechtigung hat. 

{:refdef: style="text-align: center;"}
![systemctl hat die SUID Berechtigung.]({{ site.baseurl }}/images/systemctl.png)
{: refdef}

Mit systemctl lässt sich ein Systemservice erstellen, welcher mit root Rechten läuft. 

Bei [GTFObins](https://gtfobins.github.io/gtfobins/systemctl/) findet man ein Beispiel, wie man mit systemctl und SUID Privilegien erhöhen kann.

Da TryHackMe schon verraten hat, dass die Flag unter /root/root.txt liegt, können wir diese einfach auslesen und an einen Ort kopieren, welche für unseren Useraccount lesbar ist. In unserem Fall legen wir die Flag unter /tmp/flag ab. Dazu wird über systemctl der Befehl `cat /root/root.txt > /tmp/flag` mit Rootrechten ausgeführt.

{:refdef: style="text-align: center;"}
![Mithilfe der GTFObins kommen wir an die Root Flag.]({{ site.baseurl }}/images/rootflag.png)
{: refdef}

Das ist nur eine Möglichkeit, um die Privilegien zu erhöhen. Einen weiteren coolen Ansatz habe ich hier gefunden: [https://gist.github.com/A1vinSmith/78786df7899a840ec43c5ddecb6a4740](https://gist.github.com/A1vinSmith/78786df7899a840ec43c5ddecb6a4740)
Hier wird ein Payload geschrieben, welcher einen Service ausführt, über den man dann eine reverse-shell mit Rootrechten bekommt. So könnte man direkt über die Shell auf den Ordner /root/ zugreifen und die Flag auslesen.

Ich hoffe ihr hattet Spaß beim Lesen. Vielleicht konnte ich ja sogar jemandem weiterhelfen. Mir persönlich hat die Lösung der Vulnversity sehr viel Spaß gemacht, weswegen ich auch diesen Walkthrough verfasst habe.
